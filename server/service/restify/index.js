const express = require('express');
const defaultActions = require('./action');
class Restify {
  constructor(opts = {}) {
    const prefix = opts.routerPrefix || 'REST';
    this.router = express.Router();
    this.prefix = prefix; // prefix that all Resity's api will go under
    this.models = [];     // registered models
    this.parsedModels = []; // cloned && parsed models -> to be returned at GET /PREFIX/
  }
  // validate,
  // pre,
  // action,
  // post,
  // middlewares: [
  //   {
  //     stage: 'validate',
  //     target: enum ['create', 'update', 'getAll', 'getSingle', 'delete'],
  //
  //   }
  // ]
  parseModel(model) {
    return {
      name: model.name,
      fields: _.map(model.rawAttributes, (attr) => {
        const cloneAttr = _.cloneDeep(attr);
        _.set(cloneAttr, 'Model', attr.Model.name);
        _.set(cloneAttr, 'type', attr.type.key);
        return cloneAttr;
      }).filter(attr => !attr._autoGenerated),
      associations: _.map(model.associations, (association) => {
        return {
          associationType: association.associationType,
          as: _.get(association, 'as'),
          foreignKey: _.get(association, 'foreignKey'),
          source: {
            name: _.get(association.source, 'name'),
            tableName: _.get(association.source, 'tableName'),
          },
          target: {
            name: _.get(association.target, 'name'),
            tableName: _.get(association.target, 'tableName'),
          },
        };
      }),
      operations: model.operations,
    };
  }
  validateMiddleware(mw) {
    if (!_.isPlainObject(mw)) { throw new Error('Restify middleware has to be plain object.'); }
    const validStages = ['validate', 'pre', 'action', 'post'];
    if (!_.isString(mw.stage)) { throw new Error('Restify middleware stage has to be String.'); }
    if (!_.includes(validStages, mw.stage)) { throw new Error(`Invalide stage. enum ${validStages}.`); }

    const validTargets = ['create', 'update', 'getAll', 'getSingle', 'delete'];
    if (!_.isString(mw.target)) { throw new Error('Restify middleware target has to be String.'); }
    if (!_.includes(validTargets, mw.target)) { throw new Error(`Invalide target. enum ${validTargets}.`); }

    if (!_.isFunction(mw.action)) { throw new Error('Restify action has to be fnction.'); }
  }

  register(model, opts) {
    model.operations = opts.include || ['create', 'update', 'getAll', 'getSingle', 'delete'];
    this.models.push(model);

    opts.middlewares = opts.middlewares || [];
    opts.middlewares.forEach(this.validateMiddleware);
    this.middlewares = opts.middlewares;
  }

  registerRoutes() {
    this.models.forEach((model) => {
      this.parsedModels.push(this.parseModel(model));

      const restRouter = express.Router();

      _.forEach(model.operations, (taskName) => {
        const mwRouter = express.Router();

        const middlewares = this.middlewares.filter(mw => mw.target === taskName);
        const validateMiddlewares = middlewares.filter(mw => mw.stage === 'validate');
        const preMiddlewares = middlewares.filter(mw => mw.stage === 'pre');
        const actionMiddlewares = middlewares.filter(mw => mw.stage === 'action');
        const postMiddlewares = middlewares.filter(mw => mw.stage === 'post');

        if (actionMiddlewares.length > 1) { throw new Error(`Cannot have more than one 'action' middlewares. model: ${model.name} for ${taskName}`); }

        if (actionMiddlewares.length === 0) {
          actionMiddlewares.push({ action: defaultActions[taskName](model) });
        }

        _.each(validateMiddlewares, (mw) => {
          mwRouter.use(mw.action);
        });
        _.each(preMiddlewares, (mw) => {
          mwRouter.use(mw.action);
        });
        _.each(actionMiddlewares, (mw) => {
          mwRouter.use(mw.action);
        });
        _.each(postMiddlewares, (mw) => {
          // TODO remove res from arguments as this is supposedly after res.send
          mwRouter.use(mw.action);
        });

        switch (taskName) {
          case 'create':
            restRouter.post('/', mwRouter);
            break;

          case 'update':
            restRouter.put('/:id', mwRouter);
            break;

          case 'getAll':
            restRouter.get('/', mwRouter);
            break;

          case 'getSingle':
            restRouter.get('/:id', mwRouter);
            break;

          case 'delete':
            restRouter.delete('/:id', mwRouter);
            break;

          default:
            break;
        }
      });
      this.router.use(`/${model.name}`, restRouter);
    });
  }

  // relate the registered routes to this.app
  // make sure you call this function AFTER registering all the models, routes, etc
  serve(app) {
    this.registerRoutes();
    this.router.get('/', (req, res) => {
      res.send(this.parsedModels);
    });

    app.use(`/${this.prefix}`, this.router, () => {
      throw new HttpError(404, 'Restified path not found');
    });
  }
}

module.exports = () => {
  const args = Array.prototype.slice.call(arguments);
  const restify = new Restify(...args);
  module.exports = restify;
  return restify;
};


function breakCircular(obj) {
  const seen = [];
  return JSON.parse(
    JSON.stringify(obj, (key, val) => {
      if (val != null && typeof val === 'object') {
        if (seen.indexOf(val) >= 0) return;
        seen.push(val);
      }
      return val;
    })
  );
}
